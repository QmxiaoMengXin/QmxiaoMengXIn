# JS
## 数据类型

基本类型有七种:  `null` , `undefined` , `boolean` , `number` , `string` , `symbol` , `BigInt`

其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 `Bug` (0.1+0.2 = 0.30000000000000004)。`NaN`也属于 `number` 类型，并且 `NaN` == `NaN` 为`false`。

对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型

引用数据类型：`Object`（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）

## 原型
每个函数都有 `prototype` 属性，除了 `Function.prototype.bind()`，该属性指向原型。

每个对象都有 `_proto_` 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 `[[prototype]]`，但是 `[[prototype]]` 是内部属性，我们并不能访问到，所以使用` _proto_` 来访问。

对象可以通过 `_proto_` 来寻找不属于该对象的属性，`_proto_` 将对象连接起来组成了原型链。

## 模块化
对于 `CommonJS` 和 `ES6` 中的模块化的两者区别是：

前者支持动态导入，也就是 `require(${path}/xx.js)`，后者目前不支持，但是已有提案

前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化

后者会编译成 `require/exports` 来执行的

## 防抖和节流

### 防抖
你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。

这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。

PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于`time`(设定的时间)，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（`time`）调用函数。

### 节流
防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。

## 闭包
闭包的定义很简单: 闭包就是能够读取其他函数内部变量的函数.在 `JavaScript` 中，每当函数被创建，就会在函数生成时生成闭包。

![](../\.vuepress/public/bibao.png)

## 深浅拷贝

### 浅拷贝

首先可以通过 `Object.assign` 来解决这个问题。

![](../\.vuepress/public/qiankaobei.png)

通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了

![](../\.vuepress/public/jsqian.png)


### 深拷贝

这个问题通常可以通过 `JSON.parse(JSON.stringify(object))` 来解决。

![](../\.vuepress/public/shenkaobei.png)


## call, apply, bind 区别

在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。

在说区别之前还是先总结一下三者的相似之处：

1、都是用来改变函数的this对象的指向的。

2、第一个参数都是this要指向的对象。

3、都可以利用后续参数传参。

前两者的区别:

`call` 和 `apply` 都是为了解决改变 `this` 的指向。作用都是相同的，只是传参的方式不同。

除了第一个参数外，`call` 可以接收一个参数列表，`apply` 只接受一个参数数组。

前两者跟后者的区别:

`call`和`apply`相当于立即执行函数，使用时直接调用，而`bind`则类似于函数，使用时需要加（）调用

同时`bind`传参方式与`call`相同，参数都是一个一个传递的

## Promise 

`Promise` 是 `ES6` 新增的语法，解决了回调地狱的问题。

`Promise`对象有两个特点：
1, `Promise` 对象代表一个异步操作，有三种状态：`Pending`（进行中）、`Resolved`（已完成，又称 `Fulfilled`）和`Rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态.

2, 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise` 对象的状态改变，只有两种可能：从 `Pending` 变为 `Resolved` 和从 `Pending` 变为 `Rejected`。

有了 `Promise` 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise` 对象提供统一的接口，使得控制异步操作更加容易。

`Promise` 也有一些缺点。首先，无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise` 内部抛出的错误，不会反应到外部。第三，当处于 `Pending` 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

`Promise`**基本的 api:**

1,resolve()

2,reject()

3,then()        //得到异步任务的正确结果

4,catch()       //获取异常信息

5,finally()     //不管`Promise`对象最后状态如何；都会执行操作；

5,Promise.all() // 并发处理多个异步任务，所有任务都能执行完成才能得到结果

6,Promise.race() // 并发处理多个异步任务，只要有一个任务完成就能得到结果

## async 和 await

一个函数如果加上 `async` ，那么该函数就会返回一个 `Promise`

![](../\.vuepress/public/promise.png)

`async` 和 `await` 相比直接使用 `Promise` 来说，优势在于处理 `then` 的调用链，能够更清晰准确的写出代码。缺点在于滥用 `await` 可能会导致性能问题，因为 `await`会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。

## 垃圾回收机制

### JavaScript的垃圾回收器

`JavaScript`使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因 长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。`ECMAScript`没有暴露任何垃圾回收器的接口。我们无法强迫其进 行垃圾回收，更无法干预内存管理

### Chrome V8的垃圾回收机制

**V8的回收策略**

自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策 略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件时，会被移动到老生代（晋升）






