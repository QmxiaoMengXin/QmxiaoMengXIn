{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{332:function(v,_,e){\"use strict\";e.r(_);var o=e(33),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"网络\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#网络\"}},[v._v(\"#\")]),v._v(\" 网络\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"http\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#http\"}},[v._v(\"#\")]),v._v(\" HTTP\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"HTTP发展历史:\")])]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"HTTP\")]),v._v(\"（超文本传输协议，\"),e(\"code\",[v._v(\"HyperText Transfer Protocol\")]),v._v(\")是建立在TCP协议之上的一种应用层网络协议。默认使用80端口，建立之初目的是为了将超文本标记语言(\"),e(\"code\",[v._v(\"HTML\")]),v._v(\")文档从Web服务器传送到客户端的浏览器。\"),e(\"code\",[v._v(\"WEB2.0\")]),v._v(\"以后，页面变得越来越复杂，以及ajax的出现提供了一种向服务端获取数据的新方式，这些推动着\"),e(\"code\",[v._v(\"HTTP\")]),v._v(\"协议不断扩展功能、不断优化性能：\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"HTTP/0.9\")]),v._v(\"：\"),e(\"code\",[v._v(\"1991\")]),v._v(\"年发布，极其简单，只有一个get命令；\\n\"),e(\"code\",[v._v(\"HTTP/1.0\")]),v._v(\"：\"),e(\"code\",[v._v(\"1996\")]),v._v(\"年\"),e(\"code\",[v._v(\"5\")]),v._v(\"月发布，增加了大量内容；\\n\"),e(\"code\",[v._v(\"HTTP/1.1\")]),v._v(\"：\"),e(\"code\",[v._v(\"1997\")]),v._v(\"年\"),e(\"code\",[v._v(\"1\")]),v._v(\"月发布，进一步完善HTTP协议，是目前最流行的版本；\\n\"),e(\"code\",[v._v(\"SPDY\")]),v._v(\"      ：\"),e(\"code\",[v._v(\"2009\")]),v._v(\"年谷歌发布\"),e(\"code\",[v._v(\"SPDY\")]),v._v(\"协议，主要解决\"),e(\"code\",[v._v(\"HTTP/1.1\")]),v._v(\"效率不高的问题；\\n\"),e(\"code\",[v._v(\"HTTP/2\")]),v._v(\"   ：\"),e(\"code\",[v._v(\"2015\")]),v._v(\"年借鉴\"),e(\"code\",[v._v(\"SPDY\")]),v._v(\"的\"),e(\"code\",[v._v(\"HTTP/2\")]),v._v(\"发布\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"HTTP的优化:\")])]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"HTTP\")]),v._v(\"协议建立在\"),e(\"code\",[v._v(\"TCP\")]),v._v(\"协议之上，所以\"),e(\"code\",[v._v(\"HTTP\")]),v._v(\"协议的瓶颈及其优化技巧都是基于\"),e(\"code\",[v._v(\"TCP\")]),v._v(\"协议本身的特性，比如\"),e(\"code\",[v._v(\"TCP\")]),v._v(\"的三次握手和四次挥手以及每次建立连接带来的\"),e(\"code\",[v._v(\"RTT\")]),v._v(\"延迟时间。\")]),v._v(\" \"),e(\"p\",[v._v(\"影响一个\"),e(\"code\",[v._v(\"HTTP\")]),v._v(\"网络请求的因素主要有两个：带宽和延迟.\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"在浏览器输入url回车之后发生了什么\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#在浏览器输入url回车之后发生了什么\"}},[v._v(\"#\")]),v._v(\" 在浏览器输入URL回车之后发生了什么\")]),v._v(\" \"),e(\"p\",[v._v(\"从URL输入到页面展现,总体来说分为以下几个过程:\")]),v._v(\" \"),e(\"p\",[v._v(\"（1）\"),e(\"code\",[v._v(\"URL\")]),v._v(\" 解析\")]),v._v(\" \"),e(\"p\",[v._v(\"（2）\"),e(\"code\",[v._v(\"DNS\")]),v._v(\"解析：将域名解析成 \"),e(\"code\",[v._v(\"IP\")]),v._v(\" 地址\")]),v._v(\" \"),e(\"p\",[v._v(\"（3）\"),e(\"code\",[v._v(\"TCP\")]),v._v(\" 连接：\"),e(\"code\",[v._v(\"TCP\")]),v._v(\" 三次握手\")]),v._v(\" \"),e(\"p\",[v._v(\"（4）发送 \"),e(\"code\",[v._v(\"HTTP\")]),v._v(\" 请求\")]),v._v(\" \"),e(\"p\",[v._v(\"（5）服务器处理请求并响应 \"),e(\"code\",[v._v(\"HTTP\")]),v._v(\" 报文\")]),v._v(\" \"),e(\"p\",[v._v(\"（6）浏览器解析渲染页面\")]),v._v(\" \"),e(\"p\",[v._v(\"（7）断开连接：\"),e(\"code\",[v._v(\"TCP\")]),v._v(\" 四次挥手\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"前端跨域\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前端跨域\"}},[v._v(\"#\")]),v._v(\" 前端跨域\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"什么是跨域？\")])]),v._v(\" \"),e(\"p\",[v._v(\"在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服\"),e(\"code\",[v._v(\"Ajax\")]),v._v(\"只能同源使用的限制.\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"什么是同源策略？\")])]),v._v(\" \"),e(\"p\",[v._v('同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。')]),v._v(\" \"),e(\"p\",[v._v(\"同源策略限制以下几种行为：\")]),v._v(\" \"),e(\"p\",[v._v(\"1，Cookie、LocalStorage 和 IndexDB 无法读取\")]),v._v(\" \"),e(\"p\",[v._v(\"2，DOM和JS对象无法获得\")]),v._v(\" \"),e(\"p\",[v._v(\"3，AJAX 请求不能发送\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"跨域解决方案：\")])]),v._v(\" \"),e(\"p\",[v._v(\"1，\"),e(\"code\",[v._v(\"Jsonp\")]),v._v(\"跨域 （\"),e(\"code\",[v._v(\"jsonp\")]),v._v(\"的原理就是利用\"),e(\"code\",[v._v(\"script\")]),v._v(\"标签没有跨域限制，通过\"),e(\"code\",[v._v(\"script\")]),v._v(\"标签\"),e(\"code\",[v._v(\"src\")]),v._v(\"属性，发送带有\"),e(\"code\",[v._v(\"callback\")]),v._v(\"参数的\"),e(\"code\",[v._v(\"GET\")]),v._v(\"请求，服务端将接口返回数据拼凑到\"),e(\"code\",[v._v(\"callback\")]),v._v(\"函数中，返回给浏览器，浏览器解析执行，从而前端拿到\"),e(\"code\",[v._v(\"callback\")]),v._v(\"函数返回的数据。）\")]),v._v(\" \"),e(\"p\",[v._v(\"2，\"),e(\"code\",[v._v(\"jquery Ajax\")]),v._v(\"实现\")]),v._v(\" \"),e(\"p\",[v._v(\"3,  \"),e(\"code\",[v._v(\"VUE axios\")]),v._v(\"实现\")]),v._v(\" \"),e(\"p\",[v._v(\"4,  跨域资源共享（\"),e(\"code\",[v._v(\"CORS\")]),v._v(\"）\")]),v._v(\" \"),e(\"p\",[v._v(\"5, \"),e(\"code\",[v._v(\"Nginx\")]),v._v(\"反向代理\")]),v._v(\" \"),e(\"p\",[v._v(\"6, \"),e(\"code\",[v._v(\"node.js\")]),v._v(\"中间件\")]),v._v(\" \"),e(\"h2\",{attrs:{id:\"xss和csrf攻击\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xss和csrf攻击\"}},[v._v(\"#\")]),v._v(\" XSS和CSRF攻击\")]),v._v(\" \"),e(\"h3\",{attrs:{id:\"xss\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#xss\"}},[v._v(\"#\")]),v._v(\" XSS\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"XSS\")]),v._v(\"，即 \"),e(\"code\",[v._v(\"Cross Site Script\")]),v._v(\"，中译是跨站脚本攻击；其原本缩写是 \"),e(\"code\",[v._v(\"CSS\")]),v._v(\"，但为了和层叠样式表(\"),e(\"code\",[v._v(\"Cascading Style Sheet\")]),v._v(\")有所区分，因而在安全领域叫做 \"),e(\"code\",[v._v(\"XSS\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"XSS\")]),v._v(\" 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。\")]),v._v(\" \"),e(\"p\",[v._v(\"攻击者对客户端网页注入的恶意脚本一般包括 \"),e(\"code\",[v._v(\"JavaScript\")]),v._v(\"，有时也会包含 \"),e(\"code\",[v._v(\"HTML\")]),v._v(\" 和 \"),e(\"code\",[v._v(\"Flash\")]),v._v(\"。有很多种方式进行 \"),e(\"code\",[v._v(\"XSS\")]),v._v(\" 攻击，但它们的共同点为：将一些隐私数据像 \"),e(\"code\",[v._v(\"cookie、session\")]),v._v(\" 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"XSS\")]),v._v(\"攻击可以分为\"),e(\"code\",[v._v(\"3\")]),v._v(\"类：反射型（非持久型）、存储型（持久型）、基于\"),e(\"code\",[v._v(\"DOM\")]),v._v(\"。\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"XSS 攻击的防范:\")])]),v._v(\" \"),e(\"p\",[v._v(\"现在主流的浏览器内置了防范 \"),e(\"code\",[v._v(\"XSS\")]),v._v(\" 的措施，例如 \"),e(\"code\",[v._v(\"CSP\")]),v._v(\"。但对于开发者来说，也应该寻找可靠的解决方案来防止 \"),e(\"code\",[v._v(\"XSS\")]),v._v(\" 攻击。\")]),v._v(\" \"),e(\"p\",[v._v(\"1,\"),e(\"code\",[v._v(\"HttpOnly\")]),v._v(\" 防止劫取 \"),e(\"code\",[v._v(\"Cookie\")]),v._v(\"  （\"),e(\"code\",[v._v(\"HttpOnly\")]),v._v(\" 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的\"),e(\"code\",[v._v(\"Javascript\")]),v._v(\" 访问带有 \"),e(\"code\",[v._v(\"HttpOnly\")]),v._v(\" 属性的\"),e(\"code\",[v._v(\"Cookie\")]),v._v(\"。）\")]),v._v(\" \"),e(\"p\",[v._v(\"2,输入检查 （不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 \"),e(\"code\",[v._v(\"HTML\")]),v._v(\" 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。）\")]),v._v(\" \"),e(\"p\",[v._v(\"3,输出检查 （用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 \"),e(\"code\",[v._v(\"HTML\")]),v._v(\" 页面时，可以使用编码或转义的方式来防御 \"),e(\"code\",[v._v(\"XSS\")]),v._v(\" 攻击。例如利用 \"),e(\"code\",[v._v(\"sanitize-html\")]),v._v(\"对输出内容进行有规则的过滤之后再输出到页面中。）\")]),v._v(\" \"),e(\"h3\",{attrs:{id:\"csrf\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#csrf\"}},[v._v(\"#\")]),v._v(\" CSRF\")]),v._v(\" \"),e(\"p\",[e(\"code\",[v._v(\"CSRF\")]),v._v(\"，即 \"),e(\"code\",[v._v(\"Cross Site Request Forgery\")]),v._v(\"，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。\")]),v._v(\" \"),e(\"p\",[v._v(\"通常情况下，\"),e(\"code\",[v._v(\"CSRF\")]),v._v(\" 攻击是攻击者借助受害者的 \"),e(\"code\",[v._v(\"Cookie\")]),v._v(\" 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。\")]),v._v(\" \"),e(\"p\",[e(\"strong\",[v._v(\"CSRF 攻击的防范:\")])]),v._v(\" \"),e(\"p\",[v._v(\"1,验证码  (验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 \"),e(\"code\",[v._v(\"CSRF\")]),v._v(\" 的一种辅助手段，而不能作为最主要的解决方案。)\")]),v._v(\" \"),e(\"p\",[v._v(\"2，\"),e(\"code\",[v._v(\"Referer Check\")]),v._v(\" (根据 \"),e(\"code\",[v._v(\"HTTP\")]),v._v(\" 协议，在 \"),e(\"code\",[v._v(\"HTTP\")]),v._v(\" 头中有一个字段叫 \"),e(\"code\",[v._v(\"Referer\")]),v._v(\"，它记录了该 \"),e(\"code\",[v._v(\"HTTP\")]),v._v(\" 请求的来源地址。通过 \"),e(\"code\",[v._v(\"Referer Check\")]),v._v('，可以检查请求是否来自合法的\"源\"。)')]),v._v(\" \"),e(\"p\",[v._v(\"3，添加 \"),e(\"code\",[v._v(\"token\")]),v._v(\" 验证(\"),e(\"code\",[v._v(\"CSRF\")]),v._v(\" 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 \"),e(\"code\",[v._v(\"Cookie\")]),v._v(\" 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 \"),e(\"code\",[v._v(\"Cookie\")]),v._v(\"来通过安全验证。要抵御 \"),e(\"code\",[v._v(\"CSRF\")]),v._v(\"，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 \"),e(\"code\",[v._v(\"Cookie``之中。可以在\")]),v._v(\"HTTP\"),e(\"code\",[v._v(\"请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个\")]),v._v(\"token\"),e(\"code\",[v._v(\"，如果请求中没有\")]),v._v(\"token\"),e(\"code\",[v._v(\"或者\")]),v._v(\"token\"),e(\"code\",[v._v(\"内容不正确，则认为可能是\")]),v._v(\"CSRF` 攻击而拒绝该请求)\")])])}),[],!1,null,null,null);_.default=c.exports}}]);","extractedComments":[]}