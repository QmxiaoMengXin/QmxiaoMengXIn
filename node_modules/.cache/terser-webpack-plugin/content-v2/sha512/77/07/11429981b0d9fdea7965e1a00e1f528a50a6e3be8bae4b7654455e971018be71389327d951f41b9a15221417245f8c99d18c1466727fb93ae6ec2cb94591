{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{334:function(v,e,_){\"use strict\";_.r(e);var t=_(33),o=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[_(\"h1\",{attrs:{id:\"vue\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue\"}},[v._v(\"#\")]),v._v(\" Vue\")]),v._v(\" \"),_(\"h2\",{attrs:{id:\"组件通信\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#组件通信\"}},[v._v(\"#\")]),v._v(\" 组件通信\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"props-emit\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#props-emit\"}},[v._v(\"#\")]),v._v(\" props/$emit\")]),v._v(\" \"),_(\"p\",[v._v(\"父组件\"),_(\"code\",[v._v(\"A\")]),v._v(\"通过\"),_(\"code\",[v._v(\"props\")]),v._v(\"的方式向子组件\"),_(\"code\",[v._v(\"B\")]),v._v(\"传递，\"),_(\"code\",[v._v(\"B\")]),v._v(\" to\"),_(\"code\",[v._v(\"A\")]),v._v(\" 通过在 \"),_(\"code\",[v._v(\"B\")]),v._v(\" 组件中 \"),_(\"code\",[v._v(\"$emit\")]),v._v(\", \"),_(\"code\",[v._v(\"A\")]),v._v(\" 组件中 \"),_(\"code\",[v._v(\"v-on\")]),v._v(\" 的方式实现。\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"emit-on\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#emit-on\"}},[v._v(\"#\")]),v._v(\" $emit/$on\")]),v._v(\" \"),_(\"p\",[v._v(\"这种方法通过一个空的\"),_(\"code\",[v._v(\"Vue\")]),v._v(\"实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案\"),_(\"code\",[v._v(\"vuex\")]),v._v(\"。\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"vuex\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vuex\"}},[v._v(\"#\")]),v._v(\" Vuex\")]),v._v(\" \"),_(\"p\",[_(\"code\",[v._v(\"Vuex\")]),v._v(\"实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改\"),_(\"code\",[v._v(\"State\")]),v._v(\"中的数据时，必须通过\"),_(\"code\",[v._v(\"Mutation\")]),v._v(\"进行，\"),_(\"code\",[v._v(\"Mutation\")]),v._v(\"同时提供了订阅者模式供外部插件调用获取\"),_(\"code\",[v._v(\"State\")]),v._v(\"数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走\"),_(\"code\",[v._v(\"Action\")]),v._v(\"，但\"),_(\"code\",[v._v(\"Action\")]),v._v(\"也是无法直接修改\"),_(\"code\",[v._v(\"State\")]),v._v(\"的，还是需要通过\"),_(\"code\",[v._v(\"Mutation\")]),v._v(\"来修改\"),_(\"code\",[v._v(\"State\")]),v._v(\"的数据。最后，根据\"),_(\"code\",[v._v(\"State\")]),v._v(\"的变化，渲染到视图上。\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"provide-inject\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#provide-inject\"}},[v._v(\"#\")]),v._v(\" provide/inject\")]),v._v(\" \"),_(\"p\",[_(\"code\",[v._v(\"Vue2.2.0\")]),v._v(\"新增\"),_(\"code\",[v._v(\"API\")]),v._v(\",这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过\"),_(\"code\",[v._v(\"provider\")]),v._v(\"来提供变量，然后在子孙组件中通过\"),_(\"code\",[v._v(\"inject\")]),v._v(\"来注入变量。\\n\"),_(\"code\",[v._v(\"provide\")]),v._v(\" / \"),_(\"code\",[v._v(\"inject API\")]),v._v(\" 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\")]),v._v(\" \"),_(\"h2\",{attrs:{id:\"vue生命周期\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue生命周期\"}},[v._v(\"#\")]),v._v(\" Vue生命周期\")]),v._v(\" \"),_(\"p\",[v._v(\"1，\"),_(\"code\",[v._v(\"beforeCreate\")]),v._v(\" //在实例初始化之后，数据观测 \"),_(\"code\",[v._v(\"(data observer)\")]),v._v(\"和 \"),_(\"code\",[v._v(\"event/watcher\")]),v._v(\" 事件配置之前被调用。\")]),v._v(\" \"),_(\"p\",[v._v(\"2，\"),_(\"code\",[v._v(\"created\")]),v._v(\"     //在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 \"),_(\"code\",[v._v(\"(data observer)\")]),v._v(\"，\"),_(\"code\",[v._v(\"property\")]),v._v(\" 和方法的运算，\"),_(\"code\",[v._v(\"watch/event\")]),v._v(\" 事件回调。然而，挂载阶段还没开始，\"),_(\"code\",[v._v(\"$el property\")]),v._v(\" 目前尚不可用。\")]),v._v(\" \"),_(\"p\",[v._v(\"3，\"),_(\"code\",[v._v(\"beforeMount\")]),v._v(\" //在挂载开始之前被调用：相关的 \"),_(\"code\",[v._v(\"render\")]),v._v(\" 函数首次被调用。(该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"4，\"),_(\"code\",[v._v(\"mounted\")]),v._v(\"      //载入前实例被挂载后调用，这时 \"),_(\"code\",[v._v(\"el\")]),v._v(\" 被新创建的 \"),_(\"code\",[v._v(\"vm.$el\")]),v._v(\" 替换了。如果根实例挂载到了一个文档内的元素上，当 \"),_(\"code\",[v._v(\"mounted\")]),v._v(\" 被调用时 vm.$el 也在文档内。(该钩子在服务器端渲染期间不被调.\"),_(\"code\",[v._v(\"mounted\")]),v._v(\" 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 \"),_(\"code\",[v._v(\"mounted\")]),v._v(\" 内部使用 \"),_(\"code\",[v._v(\"vm.$nextTick\")]),v._v(\".该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"5，\"),_(\"code\",[v._v(\"beforeUpdate\")]),v._v(\"  //数据更新时调用，发生在虚拟 \"),_(\"code\",[v._v(\"DOM\")]),v._v(\" 打补丁之前。这里适合在更新之前访问现有的 \"),_(\"code\",[v._v(\"DOM\")]),v._v(\"，比如手动移除已添加的事件监听器。(该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行)\")]),v._v(\" \"),_(\"p\",[v._v(\"6，\"),_(\"code\",[v._v(\"updated\")]),v._v(\"      //由于数据更改导致的虚拟 \"),_(\"code\",[v._v(\"DOM\")]),v._v(\" 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 \"),_(\"code\",[v._v(\"DOM\")]),v._v(\" 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 \"),_(\"code\",[v._v(\"watcher\")]),v._v(\" 取而代之。 \"),_(\"code\",[v._v(\"updated\")]),v._v(\" 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 \"),_(\"code\",[v._v(\"updated\")]),v._v(\" 里使用 \"),_(\"code\",[v._v(\"vm.$nextTick\")]),v._v(\".该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"7,\"),_(\"code\",[v._v(\"activated\")]),v._v(\"   //被 \"),_(\"code\",[v._v(\"keep-alive\")]),v._v(\" 缓存的组件激活时调用。(该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"8,\"),_(\"code\",[v._v(\"deactivated\")]),v._v(\"//被 \"),_(\"code\",[v._v(\"keep-alive\")]),v._v(\"缓存的组件激活时调用。(该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"9,\"),_(\"code\",[v._v(\"beforeDestroy\")]),v._v(\" //实例销毁之前调用。在这一步，实例仍然完全可用。(该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"10,\"),_(\"code\",[v._v(\"destroyed\")]),v._v(\"        //实例销毁后调用。该钩子被调用后，对应 \"),_(\"code\",[v._v(\"Vue\")]),v._v(\" 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。(该钩子在服务器端渲染期间不被调用)\")]),v._v(\" \"),_(\"p\",[v._v(\"11,\"),_(\"code\",[v._v(\"errorCaptured\")]),v._v(\"  //当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。\")])])}),[],!1,null,null,null);e.default=o.exports}}]);","extractedComments":[]}